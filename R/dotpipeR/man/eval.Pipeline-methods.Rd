\name{eval.Pipeline-methods}
\docType{methods}
\alias{eval.Pipeline}
\alias{eval.Pipeline-methods}
\alias{eval.Pipeline,character-method}
\alias{eval.Pipeline,Pipeline-method}
\alias{eval.PipelineNodes}
\title{Evaluate pipeline nodes}

\description{Evaluate a Pipeline object or a subset of its nodes.}
\section{Methods}{
\describe{

\item{\code{signature(pipeline = "character")}}{
  
}

\item{\code{signature(pipeline = "Pipeline")}}{

}
}
}

\usage{
eval.Pipeline(pipeline, nodes=get_nodes(pipeline), run.preprocessor=TRUE, recurse=FALSE, envir=environment(), ...)
eval.PipelineNodes(pipeline, nodes, load.cache=TRUE, save.cache=TRUE, cachedir=tempdir(), cacheMethod=cacheMethodDigest, run.preprocessor=TRUE, overrides=list(...),context=digest(overrides),envir=environment(),...)
}
\arguments{
  \item{pipeline}{An object of class Pipeline, such as a Pipeline generated by read.Pipeline, or a character string giving the path of a pipeline file that can be read by read.Pipeline.}
  \item{nodes}{A character vector of elements from nodes(pipeline), specifying which nodes to evaluate. The default is to evaluate all nodes.}
  \item{load.cache}{A logical value, indicating whether an image of the environment should be loaded using the caching system if found. See cache methods.}
  \item{save.cache}{A logical value, indicating whether the evaluated node should be cached to disk.}
  \item{cachedir}{A character vector giving a directory to which cached data images are saved and from which cached data images are loaded. The default value will use the R per-session temporary directory. If you want cache data to persist after an R session, you must change this.}
  \item{cacheMethod}{A function object, which returns the path of a cache file, relative to the cachedir. See Details regarding how this function is called.}
  \item{run.preprocessor}{A logical value, indicating whether the preprocessing code from the pipeline should be run before evaluating the first node}
  \item{recurse}{Internal argument used to specify whether the function is being called recursively}
  \item{overrides}{A list whose names gives nodes in the Pipeline whose values will be set to the values of the corresponding list elements instead of being evaluated the normal way.}
  \item{context}{Any R object that will be used by cacheMethod to distinguish between different contexts in which the pipeline might be run. By default, this will be a digest of the overrides.}
  \item{envir}{An environment where expressions for the node arguments will be evaluated. By default, the environment of eval.PipelineNodes is used. This is useful when a Pipeline contains a node that evaluates another (sub-)Pipeline by a recursive call to eval.Pipeline or eval.PipelineNodes; then this function can get the values of arguments from the calling function. However, this argument can be set to globalenv() to disable this behavior. This is also the environment where the preprocessor code is evaluated, and where the system will search for functions associated to the pipeline nodes.}
  \item{...}{By default, additional arguments are used to override the values of nodes, i.e. overrides is set to the list of name-value pairs matched to ... .}
}
\value{
  A Pipeline object, where the specified nodes are assigned values according to the evaluation rules.
}

\details{
eval.Pipeline will normally run significantly faster than eval.PipelineNodes with the same nodes, because eval.Pipeline stores (between calls to eval.PipelineNodes) a memory of which nodes have been evaluated, and avoids evaluating them repeatedly when evaluating their descendents.

These functions evaluate one or more nodes from a Pipeline object, in an appropriate order, with various options for controlling evaluation and caching behavior. The details of these arguments are described below, followed by the rules for how node evaluation is specified in the DOT language. 

Nodes are evaluated, beginning with the most distant ancestors in the list of nodes, followed by their descendents. Some ancestors may not need to be evaluated, e.g. if load.cache is TRUE, and cache data for all parent nodes are found.

If load.cache is TRUE, the cacheMethod function is called to get the path, relative to cachedir, of a cached data file for this node. If this file exists, it is loaded into the node's environment. If load.cache is FALSE, or no cache file exists, the node is evaluated according to the rules for evaluating pipeline nodes. If the node has parents, then eval.PipelineNodes is called recursively to evaluate the parent nodes. After all of the parent nodes have been evaluated (or loaded from cache), each of the remaining nodes is evaluated. If do.save is TRUE, the image data is saved to a file at the path returned by the cacheMethod function. The rules for evaluating pipeline nodes, after all of their parent nodes have been evaluated, are described below.

Evaluation rules

The rules for evaluating pipeline nodes are tied to the way that DOTpipeR interprets the DOT format, so it is helpful to speak in terms of the DOT grammar (as described in 'The DOT Language' document, which is available on the GraphViz website). Specifically, each line in the body (formally the "statement list") of a DOT file contains either a node statement or an edge statement (attribute statements and subgraphs are ignored), and each of these statements may contain an attributes list. The function or expression used to compute the value of a node is set within the node's attributes list. 

Two special attributes in a node's attributes list (see the DOT format specification) are reserved for specifying either a function or an expression that is used to compute the value of the node. These attributes are named "function" and "expression". The "function" attribute is used to specify a string that matches an R function to be used to evaluate the node. The "expression" attribute is used to specify a string that can be parsed to form an R expression, which can in turn be used to evaluate the node. The other essential ingredients in node evaluation are the function arguments or, in the case of expression evaluation, the variables that are made available in the environments where the nodes are evaluated.

Any argument (or variable) used in the evaluation of a function (or expression) can be given as an R expressions or it can be set to the value of another node in the pipeline. An argument (or, in the case of an expression, a variable) is set to an R expressions by explicitly writing that R expression on the right hand side (RHS) of an attribute in the node statement (N.B. often these expressions need to be enclosed in double-quotes; see "Quoting DOT identifiers containing R expressions and identifiers"). The left hand side (LHS) of the attribute specifies the argument (or variable) identifier/name, which must be quoted if it contains a period ("."). To set an argument (variable) to the value of another node, the node identifier/name is written on the LHS of the edge symbol "->" in an edge statement. For example, to use node "A" as an argument (variable) to a function (expression) that evaluates node "B", use the edge statement "A -> B [name=x]". The "name" attribute in the edge statement specifies the argument (variable) name/identifier, used to match it with a function argument identifier or variable name.

Each node in a pipeline will have a node statement with an attribute list that includes a "function" or "expression" attribute, as described above. The remaining attributes specify the function argument or variable names (on the LHS), and their values, as R expressions (on the RHS). In addition, each edge statement specifies a node whose value is assigned to an argument or variable. The LHS of each edge statement specifies the node whose value is used as input. The RHS contains the node which is evaluated using that input. The name/identifier of the argument or variable name is specified by the value of the "name" attribute in the edge statement attributes list. The list of arguments/variables is available via the getNodeArgs function.

Quoting DOT identifiers containing R identifiers and R expressions

From http://www.graphviz.org/doc/info/lang.html:

'An ID is one of the following:

Any string of alphabetic ([a-zA-Z\200-\377]) characters, underscores ('_') or digits ([0-9]), not beginning with a digit;
a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? );
any double-quoted string ("...") possibly containing escaped quotes (\")1;
an HTML string (<...>).'

The rules for mapping identifiers in the DOT syntax to R variable names and expressions are described below.
The patterns allowed for unquoted identifiers in the DOT grammar are more restrictive than those allowed for R names. Therefore, double-quoted strings are often necessary to specify the full range of valid R names and expressions with the DOT syntax.

R identifier tokens

An R function definition contains an argument list whose argument names must be given by valid R identifier tokens.

From http://cran.r-project.org/doc/manuals/r-release/R-lang.html#Identifiers:

"Identifiers consist of a sequence of letters, digits, the period ('.') and the underscore. They must not start with a digit nor underscore, nor with a period followed by a digit. The definition of a letter depends on the current locale: the precise set of characters allowed is given by the C expression (isalnum(c) || c == '.' || c == '_') and will include accented letters in many Western European locales. Notice that identifiers starting with a period are not by default listed by the ls function and that '...' and '..1', '..2', etc. are special."

In DOTpipeR, the R identifier tokens that match these argument names are specified in the DOT language in two ways: on the RHS of "name" attributes in edge statements, and as the LHS of the non-reserved attributes in node statements. 
The DOT language does not allow unquoted identifiers with periods, so identifiers in the DOT language that represent R identifier tokens which contain periods must be enclosed in double-quotes.

R expressions

The RHS of a non-reserved attribute in a node statement specifies an R expression that is evaluated and whose value is assigned to an argument or variable used in a function or expression.
Valid R expressions can include many characters that are not allowed in unquoted DOT identifiers, and also will often need to be quoted. Numerical expressions, valid R identifiers that do not contain the period ('.'), and the following list of reserved words can be provided per the DOT language without being enclosed in double-quotes:

TRUE FALSE NULL Inf NaN NA NA_integer_ NA_real_ NA_complex_ NA_character_

R expressions other than those listed above must be specified as DOT identifiers enclosed in double-quotes. Then, these identifiers will be transformed into R expressions by removing the surrounding double-quotes. Note that any double-quotes within such double-quoted string must be escaped, per the DOT language, and escaped quotes (\") will be reduced to quotes ("). Also, an escaped backslash (\\) will be reduced to a single backslash(").

"',\" '" becomes "," "

"',\\ '" becomes ",\ "

"c(1)" becomes c(1)

"\"string\"" becomes "string"

}

\references{The DOT Language: http://www.graphviz.org/doc/info/lang.html}
\author{Christopher Durden}
\keyword{pipeline}
\seealso{read.Pipeline, do.callInPipelineNode, cacheMethodDigest}
\examples{

library(dotpipeR)
dotfile <- system.file("extdata", "hello_world.dot", package="dotpipeR")
pipeline = read.Pipeline(dotfile)
pipeline = eval.Pipeline(pipeline,cachedir=tempdir(),linkWithCacheMethods=c(cacheMethodPipelineDigest))

}

